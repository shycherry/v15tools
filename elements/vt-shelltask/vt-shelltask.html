<link rel="import" href="../vt-shellworkable/vt-shellworkable.html">
<link rel="import" href="../../bower_components/shy-injecter/shy-injecter.html">
<link rel="import" href="../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<!--
    TODO(polyup): Inheriting from other custom elements is not yet supported.
    See: https://www.polymer-project.org/1.0/docs/migration.html#inheritance
 -->
<dom-module id="vt-shelltask">
  <style>
    /* TODO(polyup): For speed, consider reworking these styles with .classes
                     and #ids rather than [attributes].
    */
    [layout] {
      @apply(--layout);
    }
    [layout][horizontal] {
      @apply(--layout-horizontal);
    }
    [layout][center] {
      @apply(--layout-center);
    }
  </style>
  <link rel="import" type="css" href="vt-shelltask.css">
  <template>
    <div horizontal="" layout="" center="">
      <shadow id="parent"></shadow>
      <shy-injecter id="injecter"></shy-injecter>
      <div id="taskview" flex="">
        <template is="dom-if" if="{{_computeIf(status)}}">
          <div id="showresult" on-click="showResultClick"><div id="show">[+]</div><div id="hide">[-]</div></div>
          <template is="dom-if" if="{{_computeIf3(injected)}}">
            <span>{{injected}}</span>
          </template>
          <template is="dom-if" if="{{_computeIf4(injected)}}">
            <i>{{command}}</i>
          </template>
        </template>
        <template is="dom-if" if="{{_computeIf2(status)}}">
          <paper-input always-float-label="" label="{{injected}}" value="{{command}}"></paper-input>
        </template>
        <div id="result"></div>
      </div>
    </div>
  </template>
  <script>
    (function () {
      Polymer({
        is: 'vt-shelltask',
        properties: {
          command: {
            type: String,
            value: 'ls',
            notify: true,
            observer: 'reinjectParams',
            reflectToAttribute: true
          },
          data: { observer: 'dataChanged' },
          hasErrors: {
            type: Boolean,
            value: false
          },
          injected: {
            type: String,
            value: ''
          },
          params: { observer: 'reinjectParams' },
          result: {
            type: Boolean,
            value: false,
            notify: true,
            reflectToAttribute: true
          }
        },
        dataChanged: function () {
          this.command = this.data.command;
        },
        reinjectParams: function () {
          this.set('$.injecter.input', this.command);
          this.set('$.injecter.params', this.params);
          this.injected = this.$.injecter.getInjected();
          if (null != this.activewhenresolvable) {
            this.activated = this.$.injecter.isResolvable();
          }
        },
        showResultClick: function () {
          this.result = !this.result;
        },
        buildResultHTML: function (iResultText) {
          while (Polymer.dom(this.$.result).firstChild) {
            Polymer.dom(this.$.result).removeChild(Polymer.dom(this.$.result).firstChild);
          }
          // var resultLines = iResultText.split("\n");
          // for(var line of resultLines){
          //   var newDiv = document.createElement("div");
          //   newDiv.innerText = line;
          //   this.$.result.appendChild(newDiv);
          // }
          var newDiv = document.createElement('div');
          newDiv.innerText = iResultText;
          Polymer.dom(this.$.result).appendChild(newDiv);
        },
        doTask: function (iWorker, iCallback) {
          iCallback = iCallback ? iCallback : _.noop;
          var shellworker = iWorker;
          if (!shellworker) {
            iCallback('no worker');
            return;
          }
          if (this.status != 'enqueued') {
            iCallback();
            return;
          }
          var thisStdoutCallback = function (customEvent) {
            if (this.stdoutCallback) {
              this.stdoutCallback(customEvent);
            }
          }.bind(this);
          var thisStderrCallback = function (customEvent) {
            this.hasErrors = true;
            if (this.stderrCallback) {
              this.stderrCallback(customEvent);
            }
          }.bind(this);
          var thisFinishedCallback = function (err, result) {
            this.status = this.hasErrors ? 'error' : 'finished';
            this.fire('task_finished', {
              'src': this,
              'data': result
            });
            shellworker.removeEventListener('stdout_data', thisStdoutCallback);
            shellworker.removeEventListener('stderr_data', thisStderrCallback);
            this.buildResultHTML(result);
            iCallback(err, result);
          }.bind(this);
          this.status = 'working';
          this.hasErrors = false;
          shellworker.addEventListener('stdout_data', thisStdoutCallback);
          shellworker.addEventListener('stderr_data', thisStderrCallback);
          shellworker.doShellTask(this, thisFinishedCallback);
        },
        // extends: 'vt-shellworkable',
        _computeIf: function (status) {
          return status != 'edit';
        },
        _computeIf2: function (status) {
          return status == 'edit';
        },
        _computeIf3: function (injected) {
          return injected != '';
        },
        _computeIf4: function (injected) {
          return injected == '';
        }
      });
    }());
  </script>
</dom-module>